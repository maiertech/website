Much has been written about environment variables in SvelteKit. Yet, I was often unsure which of the
four options SvelteKit offers for environment variables is the right one. Until I realized that you
have to put the four options into the context of your hosting environment to make sense. Let's first
look at where in a SvelteKit app you might need environment variables.

## Server-side environment variables

Some of your SvelteKit code will run on a server, be it in a serverless function on Vercel or on a
Node.js server, possibly inside a Docker container. The server waits for a request, processes it,
and returns a response. The code on the server is considered secure, which means that its code and
the environment cannot be accessed or inspected. That's why you can store secrets on a server,
either in environment variables or baked into the code that runs on the server.

## Client-side environment variables

When the server sends a response, it adds client-side code that runs in the browser. This highly
optimized and bundled code is what creates a great UX for users of your SvelteKit app. The server
can send pre-bundled code containing values from environment variables, or it can dynamically add
the values of environment variables into the code it sends to the browser. In any case, these values
must not contain any secrets, because as much as you may try to obfuscate them, they are part of the
code shipped to the browser and can be inspected.

## Environment variables during the build

When you build your SvelteKit app, the build runs in a safe environment. Either on your development
machine (which you hopefully update regularly) or on a build server, for example Vercel or a service
like Railway. During the build step, the values of environment variables can be bundled into the
code. If a bundle is meant to run on the server only, it can normally contain secrets (with some
exceptions). If a bundle is meant to be shipped to the browser, it must not contain any secrets.

## Public vs. private environment variables

Therefore, SvelteKit makes a distinction between environment variables that are secrets, referred to
as **private variables**, and those that are safe to ship to a browser, referred to as **public
variables**.

When you are dealing with private variables, you have to be mindful of how you deploy your SvelteKit
app. If you deploy to Vercel, it's safe to embed private variables in code that runs on Vercel.
There is no way anyone can inspect the deployed serverless functions.

But when you deploy with a Docker container, you have to be careful. If your container is private
and can never be accessed by anyone, you can safely embed private variables into SvelteKit's server
code. But if you publish a Docker container to a registry, anyone with access could reverse engineer
the container and extract the secrets.

With the distinction between public and private variables in mind, let's look at SvelteKit's four
options for environment variables.

## 1. Static public variables

[`$env/static/public`](https://svelte.dev/docs/kit/$env-static-public): These environment variables
start with a configurable prefix, `PUBLIC_`, to signal that they are safe to ship to the browser.
They must exist at build time, not runtime. They are baked into the code during the build and cannot
be changed at runtime. Environment variables in this category are suitable for pages that are
prerendered.

Example: The public tracking ID of an analytics tool, `PUBLIC_ANALYTICS_ID`.

## 2. Dynamic public variables

[`$env/dynamic/public`](https://svelte.dev/docs/kit/$env-dynamic-public): These environment
variables cannot be accessed at build time. Therefore, they are not suitable for pages that are
prerendered. On the server, there must be an environment variable prefixed with `PUBLIC_` that can
be modified by the server during runtime. You can send this variable to the browser using a load
function.

Example: A variable that triggers maintenance mode on the server, `PUBLIC_MAINTENANCE_MODE=false`.

## 3. Static private variables

[`$env/static/private`](https://svelte.dev/docs/kit/$env-static-private): Like its public
counterpart, static private variables must exist during the build step and cannot be changed at
runtime. SvelteKit will throw an error if you try to import these variables into code that ships to
the browser. Any page that uses these variables can be prerendered. Do not use in combination with
published Docker containers.

Example: A private API key, `API_KEY`.

## 4. Dynamic private variables

[`$env/dynamic/private`](https://svelte.dev/docs/kit/$env-dynamic-private): These environment
variables cannot be accessed during the build and, like their public counterpart, are not suitable
for pages that are prerendered. They can be changed at runtime.

Example: A feature flag for a new feature, `CHAT_FEATURE_FLAG`, so DevOps can turn off the feature
without redeploying if they detect a problem.

## Common usage

When I build for Vercel, most of the time I use static private variables with `$env/static/private`.
Occasionally, I need a static public variable using `$env/static/public`, for example, to make a
`PUBLIC_ANALYTICS_ID` available client-side.

If I ship a SvelteKit app as a Docker container, I should default to dynamic private variables with
`$env/dynamic/private`. But this often interferes with prerendering. So, even with Docker, I prefer
using static environment variables. In a published Docker container, you should skip prerendering if
it means you risk exposing a secret.
