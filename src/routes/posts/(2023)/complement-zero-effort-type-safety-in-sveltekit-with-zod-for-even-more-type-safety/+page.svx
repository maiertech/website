<script>
  import { Figure } from '@maiertech/sveltekit-helpers'
  import Example1Image from './Example1Image.svelte'
  import Example2Image from './Example2Image.svelte'
</script>

SvelteKit introduced [generated types](https://kit.svelte.dev/docs/types#generated-types) a while
ago. SvelteKit would automatically generate types for `data` and `form` in
+page.svelte/+layout.svelte files and load functions and request handlers in +page.js/+layout.js,
+page.server.js/+layout.server.js and +server.js files. However, you had to annotate the types
yourself, which felt like a repetitive chore:

<Figure caption="JSDoc type annotation in +page.js." class="mb-8">

```js
/** @type {import('./$types').PageLoad} */
export async function load({ fetch, params }) {
	// `fetch` and `params` are typed.
}
```

</Figure>

<Figure caption="Another JSDoc type annotation in +page.svelte." class="mb-8">

```svelte
<script>
	/** @type {import('./$types').PageData} */
  export let data;

  // `title`, `description`, and `topic` are typed:
  const {(title, description, topics)} = data;

  //...
</script>
```

</Figure>

Yesterday, the SvelteKit team went one step further and introduced zero-effort type safety for
crucial parts of a SvelteKit app. This improvement makes manual annotations of generated types
obsolete. You get type safety for data flowing through your SvelteKit app without TypeScript
annotations. I removed a large chunk of my
[JSDoc](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html) annotations from my
website in [this pull request](https://github.com/maiertech/maier.tech/pull/660) without losing any
type safety. You can read more about zero-effort type safety in the
[announcement post](https://svelte.dev/blog/zero-config-type-safety).

Zero-effort type safety is a massive improvement for developer happiness. However, it is important
to put in additional effort to achieve complete type safety for your SvelteKit app. Besides data
_flowing through_ your SvelteKit app, you also need to keep an eye on all points where data _enters_
your SvelteKit app.

## Validation with Zod

There are three ways for data to enter your SvelteKit app:

1. By fetching data from the local file system, e.g., reading a Markdown file with a blog post or
   reading a JSON file with permitted tags.
2. By fetching data from an external API, e.g., a headless CMS or a third-party API.
3. By processing data submitted through a web form.

All three scenarios share the fact that type annotations of incoming data are moot when the data you
get is not what you expected. What you need is proper validation.

[Zod](https://zod.dev/) is a schema validation library with first-class TypeScript support. The
first thing to note is that most data coming into your app is structured, i.e., a combination of
objects and arrays that contain strings. For example, on my website, every post is in a Markdown
file. Its frontmatter has a structure that can be described with a Zod schema:

<Figure caption="src/lib/schemas/post-schema.js." class="mb-8">

```js
import { z } from 'zod';

export default z.object({
	title: z.string(),
	author: z.string(),
	description: z.string(),
	published: z.string().datetime(),
	topics: z.array(z.string()).optional(),
	tags: z.array(z.string()).optional()
});
```

</Figure>

Every property is required by default, and you can nest schemas and add additional constraints. For
example, `z.array(z.string()).optional()` means that the schema expects an optional array of
strings.

Once you have a schema, you can validate incoming data against it. In this example, I validate the
frontmatter of a post against the Zod schema in a helper function:

<Figure caption="Frontmatter validation in src/lib/posts.js." class="mb-8">

```js
const result = PostSchema.safeParse(post.metadata);

if (!result.success) {
	throw new Error(`Frontmatter of file ${path} failed validation.`);
}

const frontmatter = result.data;
const slug = slugify(frontmatter.title);
```

</Figure>

Nothing spectacular, except that `frontmatter`, which is the validated data, is now typed.

<Figure caption="Zod infers the type of validated data from the schema." class="mb-8">
	<Example1Image />
</Figure>

Not only does Zod validate the data, but it also types it, giving you full type safety for whatever
you do with the validated data.

## Validating and typing data from an API with Zod

To illustrate this further, let's look at another example in a
[form action](https://kit.svelte.dev/docs/form-actions):

<Figure caption="Validating data retrieved from an API in +page.server.js." class="mb-8">

```js
const res = await get_subscriber(validated_data.email_address);

if (!res.ok) {
	throw error(500, 'Subscription failed.');
}

// Validate subscriber.
const result = EOSubscriberSchema.safeParse(await res.json());

if (!result.success) {
	throw error(500, 'Subscription failed.');
}

const subscriber = result.data;
```

</Figure>

This form action handles data from a newsletter subscription form. At this point in the handler, I
know that the subscriber already exists, and I try to look up their status with the API helper
`get_subscriber`. I validate the API response against the Zod schema `EOSubscriberSchema`.

If the validation fails, the external API did not return subscriber info in the expected format, so
I throw a server error. If the validation succeeds, the `subscriber` variable is typed.

<Figure caption="The subscriber variable is validated and typed, thanks to Zod's type inference." class="mb-8">
  <Example2Image />
</Figure>

## Conclusion

SvelteKit's zero-effort types provide type safety when data _flows through_ your app. You should
complement zero-effort type safety with Zod schemas and validate data whenever it _enters_ your app.
Zod's type inference gives you complete type safety for validated data.
